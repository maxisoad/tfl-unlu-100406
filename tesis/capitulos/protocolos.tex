\chapter{Protocolos Web}
\label{protocolos}
\section{Definici'on}
Un protocolo de comunicaci'on es un conjunto de reglas y normas de transmisi'on, que permite a dos o m'as entidades, comunicarse entre s'i en un canal determinado. Es necesario que, antes de establecer una comunicaci'on entre partes, se definan ciertos protocolos para poder asegurar la interoperabilidad y hacer posible la comunicaci'on entre el emisor y receptor.

Las reglas definen la forma en la que debe efectuarse la comunicación, incluyendo cuestiones como la temporizaci'on, secuencia, revisi'on y correcci'on de errores. Define una \textit{sintaxis} (formato de los mensajes), una \textit{sem'antica} (significado de los mensajes) y \textit{sincronizaci'on} (secuenciamiento y temporizaci'on en la comunicaci'on).

Para implementar los protocolos, se dividen las tareas a realizar y se realizan en niveles separados (capas). Definir los modelos en capas brinda las siguientes ventajas:

\begin{enumerate}
\item Dividir la comunicaci'on  en partes m'as peque'nas y sencillas
\item normalizar los componentes de red para permitir el desarrollo y el soporte de los productos de diferentes fabricantes.
\item Permitir la interoperabilidad de diferentes tipos de hardware y software de red para comunicarse entre s'i.
\item Impedir que los cambios en una capa puedan afectar a las otras capas. Facilita la actualizaci'on del protocolo pudiendo modificar un m'odulo a reemplazarlo todo por completo.
\end{enumerate}

\section{Modelo OSI}

En los inicios de Internet, hubo un gran crecimiento tanto en cantidad como en tamaño de las redes. Debido a esto, muchas de las redes eran incompatibles entre s'i, y era extremadamente complicada la comunicaci'on entre ellas. Para solucionar este problema, la ISO\footnote{International Standard Organization}, realiz'o ciertas investigaciones acerca de los esquemas de red. En 1980 \citep{zim80}, cre'o un modelo de red para ayudar a los diseñadores de redes a poder implementar redes que puedan comunicarse entre s'i y trabajar en conjunto. Este es el modelo de referencia OSI, definida en la ISO/IEC 7498-1 \citep{osi74981}. Este modelo se agrupa en capas, cada capa agrupa una funci'on determinada. Est'an organizadas jer'arquicamente, cada capa ofrece un servicio a la capa superior.

El modelo tiene 7 capas:
\begin{itemize}
\item[7.] Aplicaci'on
\item[6.] Presentaci'on
\item[5.] Sesi'on
\item[4.] Transporte
\item[3.] Red
\item[2.] Enlace
\item[1.] F'isico
\end{itemize}
Se puede ver su distribuci'on en la Figura \ref{capasOSI}

\begin{figure}[h]
  	\centering
	\includegraphics[width=\textwidth]{img/capasOSI}
	\caption{\small Gr'afico de las capas OSI extra'ida de \cite{osi74981}}
	\label{capasOSI}
\end{figure}

\subsection{Capa de Aplicaci'on}

Proporciona servicios de red a las aplicaciones del Usuario, es la 'unica capa que no provee servicios a otra capa. Si bien es la interfaz hacia el usuario, este no interact'ua directamente con esta capa, sino que lo hace a trav'ez de una aplicaci'on que si tiene acceso directo a esta capa. Entre los protocolos de esta capa se encuentran FTP, POP, SMTP, HTTP, HTTPS, SSH entre otros.

\subsection{Capa de Presentaci'on}

Define el formato de los datos que se van a intercambiar entre 
las aplicaciones y ofrece a los programas de aplicación un 
conjunto de servicios de transformación de datos como
podemos resumir definiendo a esta capa como la encargada de manejar las estructuras de datos abstractas y realizar las conversiones de representación de datos necesarias para la correcta interpretación de los mismos

\subsection{Capa de Sesi'on}

Esta capa establece, administra y finaliza las sesiones entre las partes intervinientes en la comunicaci'on, a esto se le llama Servicio de Administraci'on de la Sesi'on. Tambi'en realiza el control del intercambio de datos y sincroniza el di'alogo entre las partes, a esto se le llama Servicio de Administraci'on del Di'alogo.

\subsection{Capa de Transporte}

Esta capa provee un Servicio de Transporte Universal. Ofrece transparencia en el intercambio de datos entre los hosts involucrados (extremo a extremo) y a'isla a las capas superiores de los detalles de implementaci'on del transporte. Asegura que los datos enviados lleguen en el mismo orden en el que han sido enviados y sin errores, brindando calidad de servicio y confiabilidad en la comunicaci'on.

\subsection{Capa de Red}

Se encarga de la conexi'on de hosts que pueden encontrarse en redes diferentes, define un esquema de direccionamiento, enrutamiento y selecci'on de rutas. Permite que los datos viajen de un extremo a otro a trav'ez de redes interconectadas. Se utilizan los paquetes como unidad de informaci'on, estos paquetes son los que se rutean a trav'ez de la red para llegar del origen al destino.

\subsection{Capa de Enlace}

Proporciona una comunicaci'on confiable entre equipos adyacentes. Se ocupa del direccionamiento f'isico, la topolog'ia de la red y el acceso a la misma. Se utilizan tramas como unidad de informaci'on, aqu'i se realizan los controles de flujo, controles de secuencia, y notificaci'on de errores.

\subsection{Capa F'isica}

Esta capa provee las caracter'isticas procedurales, funcionales, el'ectricas y mec'anicas para establecer, mantener y cerrar conexiones f'isicas. Define como se transmiten los datos al medio, recibe mensajes y los transforma en bits para su posterior env'io a trav'ez de se'nales. Ciertas caracter'isticas tales como los conectores f'isicos, niveles de voltaje, duraci'on de un bit, velocidad de los datos f'isicos, temporizaci'on y otros datos similares son definidos por las especificaciones de esta capa.

\subsection{Funciones de los Protocolos}

Entre las funciones de los protocolos se encuentran:
\begin{enumerate}
\item Encapsulamiento: 

Cada capa tiene lo que se conoce como PDU (Unidad de Datos del Protocolo), que es el resultado de la capa anterior con informaci'on propia. A medida que los datos van bajando a trav'ez de las capas se agregan encabezados y eventualmente una cola a los datos con informaci'on correspondiente a cada capa. Estos agregados contienen informaci'on de control para asegurar la entrega de los datos y la correcta interpretaci'on de los mismos en el receptor. Una vez que se re'una la informaci'on de todas las capas, se convierten en bits y son enviadas por el medio f'isico. En la Figura \ref{encapsulamiento} puede verse como se van acoplando las PDUs a medida que se avanza hacia abajo en el Modelo OSI.

\begin{figure}[h]
  	\centering
	\includegraphics[width=\textwidth]{img/encapsulamiento}
	\caption{\small Encapsulamiento en el Modelo OSI, extra'ida de \cite{encapsulamiento}}
	\label{encapsulamiento}
\end{figure}
\item Establecimiento, control y cierre de la conexi'on.
\item Control de Flujo:
Asegurar que la velocidad de los datos no sature las posibilidades particulares de cada capa.
\item Control de Errores: Detecci'on y correcci'on de errores.
\item Multiplexaci'on: Posibilidad de compartir el canal entre varias conexiones.
\item Encriptaci'on y compresi'on.
\end{enumerate}

\section{TCP/IP}

perros

\section{HTTP}
\label{http}
Las siglas de este protocolo son por HyperText Transfer Protocol (Protocolo de Transferencia de Hipertexto). Es un protocolo de capa de aplicaci'on\footnote{PONER ACA ALGO DEL MODELO OSI} que sirve para distribuir informaci'on. Fu'e utilizado en la Web desde el a'no 1990 en su primera versi'on (0.9), en la que simplemente se pod'ia transferir texto plano. Su evoluci'on fue el est'andar 1.0 en el que se mejor'o el protocolo permitiendo que los mensajes usen el formato \gls{mime}, se incorporaron metadatos acerca de la informaci'on transferida y modificadores en la sem'antica de petici'on/respuesta. La revisi'on del protocolo que se usa actualmente es la 1.1, definida en la RFC1626\citep{rfcHTTP1.1}. Contiene nuevos metodos, headers y otras caracter'isticas. Las principales diferencias de esta 'ultima definici'on se pueden ver en \citep{http1011}.

El contenido web reside en Servidores, estos son los que se comunican utilizando este protocolo entre otros. Sirven \textsc{recursos}, estos recursos pueden ser p'aginas HTML, im'agenes, PDF's, video, etc, tanto contenido est'atico como din'amico (generado a demanda). Debido a la gran diversidad de contenido que provee un Servidor, es necesario identificar el tipo de recurso que se est'a enviando. Esto se hace utilizando una etiqueta llamada MIME-Type, que define el tipo de contenido a transferir.

Cada recurso del servidor tiene un nombre, para que los clientes puedan apuntar directamente al recurso deseado. Se nombra con una URL, que tiene el siguiente formato:

\begin{quote}
PROTOCOLO://SERVIDOR/PATH\_AL\_RECURSO/RECURSO
\end{quote}

El funcionamiento b'asico es, el cliente env'ia una petici'on al Servidor (al puerto 80 por defecto) y este le responde. Esta comunicaci'on se realiza a trav'ez de mensajes HTTP. Existen diferentes m'etodos que se pueden utilizar cuando se env'ia una petici'on al servidor, tales como

\begin{enumerate}
\item GET - El cliente solicita un recurso espec'ifico del servidor.
\item POST - El cliente env'ia datos que van a ser utilizados por el servidor.
\item HEAD - El cliente solicita s'olo los Headers (se detallar'an m'as adelante).
\end{enumerate}

Estos son algunos de los m'etodos, hay otros tales como PUT, DELETE, etc. Seg'un el m'etodo, el servidor opera de manera diferente. En la petici'on se env'ia el m'etodo, el recurso solicitado, la versi'on del protocolo utilizado, el host, el user-agent\footnote{Qui'en est'a generando la petici'on, por ejemplo Mozilla o Safari (browser, proxy, etc.).}, entre otros.
El Servidor, responde a la petici'on con una respuesta, que contiene un c'odigo de estado de 3 d'igitos que le dice al cliente que la petici'on fue exitosa u otras, por ejemplo 200 (OK) o 404 (Documento no encontrado) de los m'as comunes.

Los mensajes de HTTP consisten en peticiones y respuestas, sus formatos son similares. Consisten en 3 partes:

\begin{enumerate}
\item Linea Inicial - Se indica que hacer en la petici'on o que fue lo que pas'o en la respuesta.
\item Headers - Ac'a se pueden definir diferentes par'ametros por c'ada l'inea con la sintaxis ''nombre:valor''.
\item Cuerpo - Esta parte contiene los datos enviados, ya sea del cliente al servidor o viceversa.
\end{enumerate}

El formato de una petici'on es el siguiente:

\begin{quote}
$<$m'etodo$>$ $<$url del recurso$>$ $<$versi'on$>$

$<$headers$>$

$<$cuerpo$>$
\end{quote}

El formato de la respuesta es el siguiente:

\begin{quote}
$<$versi'on$>$ $<$estado$>$ $<$descripci'on del estado$>$

$<$headers$>$

$<$cuerpo$>$
\end{quote}

\subsection{HEADERS}
\label{headers}
Los Headers, a'naden informacion adicional a las peticiones y respuestas. El protocolo define varios Headers, pero se pueden inventar tambi'en, los servidores y clientes son libres de hacerlo. Hay diferentes tipos de Headers, entre los que se encuentran:

\begin{enumerate}
\item Headers Generales

Pueden aparecer en peticiones y respuestas.
\item Headers de Peticiones.

Proveen m'as informaci'on acerca de las peticiones.
\item Headers de respuesta.

Proveen m'as informaci'on acerca de las respuestas.
\item Entity Headers (ENTIDAD?)

Proveen informaci'on acerca del recurso del mensaje.
\item Headers de Extensi'on

Permite agregar nuevos headers que no est'en dentro de la especificaci'on.\footnote{PONER LA ESPECIFICACION}
\end{enumerate}

La definici'on completa de los Headers se encuentra en la Secci''on 14 de \citep{rfcHTTP1.1}.

\section{HTTPS}

Este protocolo, es la versi'on ''segura'' de HTTP, a diferencia de este protocolo, a'nade una capa de cifrado utilizando SSL/TLS sobre TCP. Esto permite que los datos que viajen entre cliente y servidor vayan encriptados, esto se hace antes de enviar los datos por la red. Se distingue f'acilmente porque el formato de la URL empieza con https:// y la conexi'on se hace por el puerto 443 por defecto. Es decir, cuando el browser hace una petici'on a un servidor, si el esquema es https, inicia la conexi'on segura con el servidor.

La conexi'on se hace con otro puerto diferente al de HTTP ya que SSL es un protocolo binario, completamente diferente. Si ambos llegaran al mismo puerto, los servidores interpretarian SSL como HTTP err'oneo y cerrar'ian la conexi'on.

El procedimiento para iniciar la conexi'on es el siguiente: El cliente abre una conexi'on con el puerto 443 al servidor. Una vez que la conexi'on TCP est'a establecida, el cliente y el servidor inicializan la capa SSL negociando algunos par'ametros criptogr'aficos e intercambiando llaves. Una vez concluida esta negociaci'on, ya pueden empezar a intercambiar mensajes encriptados.

\section{SPDY}

Es un protocolo de aplicaci'on que a'nade una capa de sesi'on sobre SSL que permite la transmisi'on de m'ultiples Streams\footnote{Flujo de Datos.} sobre una conexi'on TCP. Especifica un nuevo formato de trama para codificar y transmitir datos.
Su especificaci'on se puede ver en \citep{spdyWhitepaper} y su draft se puede encontrar en \citep{spdyDraft}.

El protocolo HTTP no tiene estado, y, por cada recurso existe la necesidad de abrir una conexi'on nueva y cerrarla. Esto trae varios problemas. Por cada conexi'on nueva que se hace, se necesitan varios mensajes para establecer la conexi'on TCP, lo que trae varios RTT adicionales a la comunicaci'on. Retrasos debido al ''Slow Start''\footnote{Se comienza enviando un volumen de datos pequeño hasta alcanzar cierto valor llamado Umbral de Congesti'on} de TCP. Clientes que evitan realizar m'ultiples conexiones con el mismo servidor (hasta 6 actualmente PONER REF). A su vez, los servidores crean varios subdominios para almacenar el contenido para que los clientes puedan realizar las peticiones sin tener que evitar las m'ultiples conexiones a un mismo dominio.

SPDY ofrece por sobre HTTP las siguientes mejoras:

\begin{enumerate}
\item Peticiones Multiplexadas. No existen l'imites de peticiones que se pueden realizar en una sesi'on de SPDY. A causa de que las peticiones son multiplexadas aumenta la eficiencia del protocolo TCP.
\item Priorizaci'on de Peticiones. Los clientes pueden solicitar al servidor cu'ales recursos quiere obtener antes que otros. Esto evita la congesti'on de recursos que no son cr'iticos cuando todav'ia est'a pendiente el env'io de algun recurso que tiene una prioridad mayor.
\item Compresi'on de Headers. A causa de que hoy en d'ia los clientes env'ian mucha informaci'on redundante en forma de Headers, como la cantidad de peticiones para obtener un sitio promedio va desde 50 a 100, esta cantidad de informaci'on es relevante. Comprimir los Headers reduce el ancho de banda utilizado.
\item Server Push. Al permitir la comunicaci'on bi-direccional a trav'ez de streams, cualquiera de los 2 (cliente o servidor) puede iniciar un stream hacia el otro. El servidor puede enviar un recurso al cliente antes de que este lo pida\footnote{El servidor conoce de antemano que el cliente va a necesitar el recurso en cuesti'on.}, esto reduce el tiempo de carga del sitio y disminuye la cantidad de peticiones del cliente.
\item Server Hint. El servidor puede ''sugerirle'' al cliente que pida un recurso en particular, ya que lo va a necesitar. De todas maneras, el servidor espera a que el cliente peticione el recurso en cuesti'on antes de enviarlo. Esto reduce el tiempo que tarda el cliente en descubrir cuales son los recursos que tiene que pedirle al servidor.
\end{enumerate}

SPDY se enfoca en la manera en la que se transmiten los datos por la red, preserva toda la sem'antica del protocolo HTTP. De esta manera, para las aplicaciones se implementa de manera transparente, ya que reside entre la capa de aplicaci'on y la de transporte. Esta sesi'on es similar al par petici'on-respuesta de HTTP. Es obligatoria la compresi'on del mensaje.